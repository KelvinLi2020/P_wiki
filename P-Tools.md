The typical workflow associated with using the P programming system is as follows.

The programmer provides P programs - in the form of .p files - as an input to the P compiler.
The compiler runs a lightweight static analysis which may produce
error messages.
Once the programmer fixes all the statically discovered errors, the compiler
produces two outputs---C code for execution and a .NET assembly (.dll file) for the P runtime called PTester.
Next, PTester's executable - called pt.exe - runs on the .dll file and performs systematic testing of the P program, by exploring various interleaved execution.
If an error is discovered, a complete error trace starting from the initial 
state of the program is dumped on the disk in a text file.
The programmer fixes the bug and runs the compiler and PTester again on the modified 
program.
At any point in this process, the programmer could also choose to compile the 
generated C code along with the foreign code and run it. 

In addition to the compiler and testing tool, two visualizers are available for writing and debugging P programs.

**PVisualizer** displays the state machine structure of the P program, which could be a useful aid in program comprehension, especially when
the number of states and transitions become large.
The visualizer is launched by running `PVisualizer.exe` from the command line.
A P file can be loaded (and refreshed) through the drop-down menu at the top.

**TraceVisualizer** tool can be used to display the execution trace of a 
P program generated by the PTester runtime in the form of a Message Sequence Chart. 
See [here](https://github.com/p-org/TraceVisualizer) for more details on how to use the TraceVisualizer.

## Compilation
The compiler executable is called `pc.exe`.
It takes P files and optional arguments as input.
The options can be discovered by running `pc.exe /?` from the command line.
Parameters in the commands below are chosen as an example.

As an example, consider the case of three P files: `foo.p`, `bar.p` and `TestScript.p`.
For more on the test script files, see [here](https://github.com/p-org/P/wiki/Test-Script-Files).
Suppose that there are two tests in `TestScript.p`: `Test01` and `Test2`.

**First, consider the case when compilation is performed to systematically test the P program.**

To generate files used by the PTester for systematic testing, P program has to be compiled into C#.

When the following command runs:

`pc.exe /generate:C# foo.p bar.p /t:foo.4ml`

the following files are generated (provided there's no static errors): `foo.cs` and
 `foo.4ml`.

Next, the linking command

`pc.exe /generate:C# /link TestScript.p /r:foo.4ml`

generates `Test1.cs`, `Test2.cs`, `Test1.dll`, `Test2.dll`. 

`Test1.dll` and `Test2.dll` are intended for systematically testing the 
(potentially nondeterministic) executions of the P program specified in the tests
`Test1` and `Test2` of `TestScript.p`. For more details on how to run PTester, see 
section "Systematic Testing" below.

**Second, consider the case when compilation is performed to generate C code from the P program.**

The commands would be as follows:

`pc.exe /generate:C foo.p bar.p /t:foo.4ml`

The following files are generated by these commands (provided there's no static errors): `foo.c`, `foo.h`,
 `foo.4ml`.

The linking command

`pc.exe /generate:C /link /r:foo.4ml`

generates `linker.c` and `linker.h`. 

## Systematic Testing
To test a P program systematically along different execution paths, the programmer
must run `pt.exe` on the dll generated by the P compiler, e.g.

`pt.exe Test0.dll`

Run `pt.exe /?` to get the full list of options for PTester.
The most frequently used options are:

 `/psharp`, used when your program checks liveness properties; PTester uses PSharpTester's liveness algorithm;

 `-v` or `-verbose`, used when you want to study execution traces generated by PTester for various interleavings; this option is needed when you intend on using TraceVisualizer to display the execution traces.

Below is the testing command for our example that checks liveness properties and dumps execution traces into `trace.txt` file:

`pt.exe /psharp -v Test0.dll >trace.txt`

Note that if PTester finds an execution error in your program (for example, assert violation), the error trace would be generated by default, regardless of whether you supplied the `-v` option.

You can find another example of running P tools in a more involved case - when P program depends on other P programs - in the [Hello](https://github.com/p-org/P/wiki/Hello) example of the Tutorial.

  