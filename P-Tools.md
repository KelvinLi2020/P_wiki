The typical workflow associated with using the P programming system is as follows.

The programmer provides a P program as input to the P compiler.
The compiler runs a lightweight static analysis which may produce
error messages.
Once the programmer fixes all the statically discovered errors, the compiler
produces two outputs---C code for execution and a .NET assembly (dll) for P runtime called PTester.
Next, PTester's executable - called pt.exe - runs on the .dll file and performs systematic testing of the P program, by exploring various interleaved execution.
If an error is discovered, a complete error trace starting from the initial 
state of the program is dumped on the disk in a text file.
The programmer fixes the bug and runs the compiler and PTester again on the modified 
program.
At any point in this process, the programmer could also choose to compile the 
generated C code along with the foreign code and run it. 

In addition to the compiler and testing tool, two visualizers are available for writing and debugging P programs.

**PVisualizer** displays the state machine structure of the P program, which could be a useful aid in program comprehension, especially when
the number of states and transitions become large.
The visualizer is launched by running `PVisualizer.exe` from the command line.
A P file can be loaded (and refreshed) through the drop-down menu at the top.

**TraceVisualizer** tool can be used to display the execution trace of a 
P program generated by the PTester runtime in the form of a Message Sequence Chart. 
See [here](https://github.com/p-org/TraceVisualizer) for more details on how to use the TraceVisualizer.

## Compilation
The compiler executable is called `pc.exe`.
It takes P files and optional arguments as input.
The options can be discovered by running `pc.exe /?` from the command line.
Parameters in the commands below are chosen as an example.

As an example, consider the case of three P files: foo.p, bar.p and TestScript.p.
For more on the test script files, see [here](https://github.com/p-org/P/wiki/Test-Script-Files).
When the following commands 

`pc.exe /generate:C# /shared foo.p /t:foo.4ml /outputDir:..\Output`
`pc.exe /generate:C# /shared bar.p /t:bar.4ml /outputDir:..\Output` 

are run, the following files are generated (provided there's no static errors): `foo.cs`,
 `foo.4ml`, `bar.cs`, `bar.4ml`.

Next, the linking command

`pc.exe /generate:C# /link /shared TestScript.p /r:foo.4ml /r:bar.4ml`

generates `Test0.cs` and `Test0.dll`. 

The first file is intended for systematically testing the 
(potentially nondeterministic) executions of `foo.p` 
(discussed in Section [#sec-systematic-testing]).
The last three files are intended for executing `foo.p` (discussed in Section [#sec-execution]).

## Systematic Testing { #sec-systematic-testing }
To test a P program systematically along different execution paths, the programmer
must run `Zinger.exe` on the dll generated by the P compiler, e.g.
`Zinger.exe foo.dll`.
Run `Zinger.exe /?` to get the full list of options for Zinger.
A good set of default options are as follows: 

    `-s -delayB:<PlangDist>\Compiler\RunToCompletionDelayingScheduler.dll -et:trace.txt`
    
With these options, Zinger prints search statistics 
periodically (-s option),
uses the Run-To-Completion delaying scheduler for search (-delayB option),
and prints the trace for any error discovered in the file 
`trace.txt` (-et option). 
The detection of infinite erroneous executions (in the presence of liveness monitors)
is not turned on by default because it is expensive.
To turn that feature on, use the `-liveness` option.

## Execution { #sec-execution }
The Runtime folder contains two sub-folders---Headers and Lib.
The Headers folder contains C header files required for 
compiling the outputs program.h, program.c, and stubs.c.
The Lib folder contains a dynamically-loaded dll for the P
runtime.
To execute your application, fill in the missing functions in 
stubs.c (resulting from the use of model machines and functions)
and compile your application using the standard C compiler.
  