The typical workflow associated with using the P programming system is as follows.

The programmer provides a P program as input to the P compiler.
The compiler runs a lightweight static analysis which may produce
error messages.
Once the programmer fixes all the statically discovered errors, the compiler
produces two outputs---C code for execution and a .NET assembly (dll) for P runtime called PTester.
Next, PTester's executable - called pt.exe - runs on the .dll file and performs systematic testing of the P program, by exploring various interleaved execution.
If an error is discovered, a complete error trace starting from the initial 
state of the program is dumped on the disk in a text file.
The programmer fixes the bug and runs the compiler and PTester again on the modified 
program.
At any point in this process, the programmer could also choose to compile the 
generated C code along with the foreign code and run it. 

In addition to the compiler and testing tool, the P distribution also has two visualizers.
PVisualizer displays the state machine structure of the P program, which could be a useful aid in program comprehension, especially when
the number of states and transitions become large.
The visualizer is launched by running `PVisualizer.exe` from the command line.
A P file can be loaded (and refreshed) through the drop-down menu at the top.

The TraceVisualizer tool can be used to display the execution trace of a 
P program generated by the PTester runtime in the form of a Message Sequence Chart. 
See [here](https://github.com/p-org/TraceVisualizer) for more details on how to use the TraceVisualizer.
----------------
The P distribution is available in four configurations given by the matrix 
{Debug, Release} x {x86, x64}.
For example, the folder for Debug tools under x86 is called `Plang_Debug_x86`.
Inside this folder, there are two sub-folders---Compiler and Runtime.
The Compiler folder contains all the tools for visualizing, compiling, 
and testing a P program.
The Runtime folder contains the binaries and header files for the P runtime 
library. 
To generate the executable binary for the P program, a standard C compiler is 
used to compile the auto-generated and manually-written code 
against the header files and then link against the P runtime library. 
----------------------
## Compilation
The compiler executable is called `pc.exe`.
It takes P files and optional arguments as input.
The options can be discovered by running `pc.exe /?` from the command line.
As an example, consider the case of two P files (foo.p and bar.p) and a test script file ().
When the command `pc.exe foo.p` is run, four files are generated---`foo.dll`,
`program.h`, `program.c`, and `stubs.c`.
The first file is intended for systematically testing the 
(potentially nondeterministic) executions of `foo.p` 
(discussed in Section [#sec-systematic-testing]).
The last three files are intended for executing `foo.p` (discussed in Section [#sec-execution]).

## Systematic Testing { #sec-systematic-testing }
To test a P program systematically along different execution paths, the programmer
must run `Zinger.exe` on the dll generated by the P compiler, e.g.
`Zinger.exe foo.dll`.
Run `Zinger.exe /?` to get the full list of options for Zinger.
A good set of default options are as follows: 

    `-s -delayB:<PlangDist>\Compiler\RunToCompletionDelayingScheduler.dll -et:trace.txt`
    
With these options, Zinger prints search statistics 
periodically (-s option),
uses the Run-To-Completion delaying scheduler for search (-delayB option),
and prints the trace for any error discovered in the file 
`trace.txt` (-et option). 
The detection of infinite erroneous executions (in the presence of liveness monitors)
is not turned on by default because it is expensive.
To turn that feature on, use the `-liveness` option.

## Execution { #sec-execution }
The Runtime folder contains two sub-folders---Headers and Lib.
The Headers folder contains C header files required for 
compiling the outputs program.h, program.c, and stubs.c.
The Lib folder contains a dynamically-loaded dll for the P
runtime.
To execute your application, fill in the missing functions in 
stubs.c (resulting from the use of model machines and functions)
and compile your application using the standard C compiler.
  