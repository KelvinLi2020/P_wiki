The typical workflow associated with using the P programming system is as follows.

The programmer provides a P program as input to the P compiler.
The compiler runs a lightweight static analysis which may produce
error messages.
Once the programmer fixes all the statically discovered errors, the compiler
produces two outputs---C code for execution and a .NET assembly (dll) for P runtime called PTester.
Next, PTester's executable - called pt.exe - runs on the .dll file and performs systematic testing of the P program, by exploring various interleaved execution.
If an error is discovered, a complete error trace starting from the initial 
state of the program is dumped on the disk in a text file.
The programmer fixes the bug and runs the compiler and PTester again on the modified 
program.
At any point in this process, the programmer could also choose to compile the 
generated C code along with the foreign code and run it. 

In addition to the compiler and testing tool, two visualizers are available for writing and debugging P programs.

**PVisualizer** displays the state machine structure of the P program, which could be a useful aid in program comprehension, especially when
the number of states and transitions become large.
The visualizer is launched by running `PVisualizer.exe` from the command line.
A P file can be loaded (and refreshed) through the drop-down menu at the top.

**TraceVisualizer** tool can be used to display the execution trace of a 
P program generated by the PTester runtime in the form of a Message Sequence Chart. 
See [here](https://github.com/p-org/TraceVisualizer) for more details on how to use the TraceVisualizer.

## Compilation
The compiler executable is called `pc.exe`.
It takes P files and optional arguments as input.
The options can be discovered by running `pc.exe /?` from the command line.
Parameters in the commands below are chosen as an example.

As an example, consider the case of three P files: foo.p, bar.p and TestScript.p.
For more on the test script files, see [here](https://github.com/p-org/P/wiki/Test-Script-Files).
When the following commands 

`pc.exe /generate:C# /shared foo.p /t:foo.4ml /outputDir:..\Output`
`pc.exe /generate:C# /shared bar.p /t:bar.4ml /outputDir:..\Output` 

are run, the following files are generated (provided there's no static errors): `foo.cs`,
 `foo.4ml`, `bar.cs`, `bar.4ml`.

Next, the linking command

`pc.exe /generate:C# /link /shared TestScript.p /r:foo.4ml /r:bar.4ml`

generates `Test0.cs` and `Test0.dll`. 

'Test0.dll` is intended for systematically testing the 
(potentially nondeterministic) executions of `foo.p` discussed in the next section.

## Systematic Testing
To test a P program systematically along different execution paths, the programmer
must run `pt.exe` on the dll generated by the P compiler, e.g.

`pt.exe Test0.dll`

Run `pt.exe /?` to get the full list of options for PTester.
The most frequently used options are:

 `/psharp`, used when your program checks liveness properties; PTester uses PSharpTester's liveness algorithm;

 `-v` or `-verbose`, used when you want to study execution traces generated by PTester for various interleavings; this option is needed when you intend on using TraceVisualizer to display the execution traces.

Below is the testing command for our example that checks liveness properties and dumps execution traces into `trace.txt` file:

`pt.exe /psharp -v Test0.dll >trace.txt`

Note that if PTester finds an execution error in your program (for example, assert violation), the error trace would be generated by default, regardless of whether you supplied the `-v` option.


  