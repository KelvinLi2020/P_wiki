Tools { #sec-tools }

![workflow]

The typical workflow associated with using the P programming system is shown in the 
figure above. 
The programmer provides a P program (shown on the left of the figure)
as input to the P compiler.
The compiler runs a lightweight static analysis which may produce
error messages.
Once the programmer fixes all the statically discovered errors, the compiler
produces two outputs---C code for execution and Zing model for systematic testing.
The latter output comprises both the Zing model and a compiled version of it 
in the form of a .NET assembly.
Next, the programmer feeds this .NET assembly to the Zinger tool which tests
the program along various interleaved executions.
If a dynamic error is discovered, a complete error trace starting from the initial 
state of the program is dumped on the disk in a text file (see -et option of Zinger).
The programmer fixes the bug and runs the compiler and Zinger again on the modified 
program.
At any point in this process, the programmer could also choose to compile the 
generated C code along with the foreign code and run it. 

In addition to the compiler and testing tool, the P distribution also has a 
visualizer to graphically display the state machine structure of the P code.
The visualization is a useful aid in program comprehension, especially when
the number of states and transitions become large.

The P distribution is available in four configurations given by the matrix 
{Debug, Release} $\times$ {x86, x64}.
For example, the folder for Debug tools under x86 is called `Plang_Debug_x86`.
Inside this folder, there are two sub-folders---Compiler and Runtime.
The Compiler folder contains all the tools for visualizing, compiling, 
and testing a P program.
The Runtime folder contains the binaries and header files for the P runtime 
library. 
To generate the executable binary for the P program, a standard C compiler is 
used to compile the auto-generated and manually-written code 
against the header files and then link against the P runtime library. 

## Visualization
The visualizer is launched by running `PVisualizer.exe` from the command line.
A P file can be loaded (and refreshed) through the drop-down menu at the top.

## Compilation
The compiler executable is called `pc.exe`.
It takes a P file and optional arguments as input.
The options can be discovered by running `pc.exe /?` from the command line.
When the command `pc.exe foo.p` is run, four files are generated---`foo.dll`,
`program.h`, `program.c`, and `stubs.c`.
The first file is intended for systematically testing the 
(potentially nondeterministic) executions of `foo.p` 
(discussed in Section [#sec-systematic-testing]).
The last three files are intended for executing `foo.p` (discussed in Section [#sec-execution]).

## Systematic Testing { #sec-systematic-testing }
To test a P program systematically along different execution paths, the programmer
must run `Zinger.exe` on the dll generated by the P compiler, e.g.
`Zinger.exe foo.dll`.
Run `Zinger.exe /?` to get the full list of options for Zinger.
A good set of default options are as follows: 

    `-s -delayB:<PlangDist>\Compiler\RunToCompletionDelayingScheduler.dll -et:trace.txt`
    
With these options, Zinger prints search statistics 
periodically (-s option),
uses the Run-To-Completion delaying scheduler for search (-delayB option),
and prints the trace for any error discovered in the file 
`trace.txt` (-et option). 
The detection of infinite erroneous executions (in the presence of liveness monitors)
is not turned on by default because it is expensive.
To turn that feature on, use the `-liveness` option.

## Execution { #sec-execution }
The Runtime folder contains two sub-folders---Headers and Lib.
The Headers folder contains C header files required for 
compiling the outputs program.h, program.c, and stubs.c.
The Lib folder contains a dynamically-loaded dll for the P
runtime.
To execute your application, fill in the missing functions in 
stubs.c (resulting from the use of model machines and functions)
and compile your application using the standard C compiler.
  